import pandas as pd
import numpy as np
import array

# ============================== Встроенный модуль "array" ===========================
"""
L = list(range(10))
A = array.array('i', L)
print(A)
"""
# ====================================================================================


# ============================ 1. Массивы модуля NumPy ==================================
# print(np.array([range(i, i + 3) for i in [2, 4, 6]], dtype='int'))  # float32 - тип
# ====================================================================================


# =============================== 2. Создание массивов с нуля  =============================
my_array = np.zeros(10, dtype=int)  # нулевой массив
print(my_array)

my_array = np.ones((3, 5), dtype=float)  # массив значений 1 с размером 3х5
print('\n', my_array)

my_array = np.full((3, 5), 3.14)  # массив значений 3.14 с размером 3х5
print('\n', my_array)

my_array = np.arange(0, 20, 2)  # массив значений с 0 до 20 с шагом 2
print('\n', my_array)

my_array = np.linspace(0, 1, 5)  # массив из 5 значений равномерно распологающихся между 0 и 1
print('\n', my_array)

my_array = np.random.random((3, 3))  # массив 3х3 равномерно распределенных
print('\n', my_array)

my_array = np.random.normal(0, 1, (3, 3))  # массив 3х3 случайных значений с медианой 0 и стандартным отклонением 1
print('\n', my_array)

my_array = np.random.randint(0, 10, (3, 3))  # массив 3х3 случайных значений в промежутке [0:10)
print('\n', 'массив 3х3 случайных значений в промежутке [0:10): ', '\n', my_array)

my_array = np.eye(3)  # единичная матрица 3х3
print('\n', my_array)

my_array = np.empty(3)  # массив 3х3 целочисленных значений. Значения случайные из ячеек памяти
print('\n', my_array, '\n')
print('\n')
# =======================================================================================


# ================================ Стандартные типы данных ======================================
# todo: bool_ - булевый типб хранящийся в виде 1 байта
# todo: int_ - целочисленное значение по умолчанию (аналогичен типу long в С обычно int64 или int32)
# todo: intc - Идентичен типу int из С (обычно int64 или int32)
# todo: ...
# ===============================================================================================


# ============================== Атрибуты массивов NumPy =========================================
# todo: Определение размера, формы, объема занимаемой памяти и типов данных массива
my_array = np.random.seed(0)  # начальное зачение для целей воспроизводимости

x1 = np.random.randint(10, size=6)
x2 = np.random.randint(10, size=(3, 4))
x3 = np.random.randint(10, size=(3, 4, 5))

print('Массив с параметрами:(10, size=(3, 4)):', '\n', x2)
print('x2 ndim: ', x2.ndim)
print('x2 shape: ', x2.shape)
print('x2 size: ', x2.size, '\n')

# todo: У каждого массива есть атрибуты: ndim(размерность), shape(размер каждого измерения), size(общий размер массива, кажется кол-во элементов)
print('Массив с параметрами:(10, size=(3, 4, 5)):', '\n', x3)
print('x3 ndim: ', x3.ndim)
print('x3 shape: ', x3.shape)
print('x3 size: ', x3.size)
print('x3 dtype: ', x3.dtype)
print('itemsize: ', x3.itemsize, 'bytes')
print('nbytes: ', x3.nbytes, 'bytes')
# ===============================================================================================


# ================================= Индексация массива: доступ к отдельным элементам =================================
print(x1[0])  # вывод 0-го элемента
print(x1[-1])  # для индексации с конца массива можно использовать отрицателдьные значения, вывод 9
print('Обращаться к элементам в многомерном массиве можно с помощью разделенных запятой кортежей индексов x2[0, 0]: ', x2[0, 0])
x2[0, 0] = 12  # Тем же способом можно изменять значения по индексу
print('Измененный массив x2[0, 0] = 111: ', '\n', x2)
x1[0] = 3.14159
print('В отличие от списков Пайтон у массивов Нампи фиксированный тип данных, в этом случае значение будет усечено x1[0] = 3.14159: ', '\n', x1, '\n')
# ====================================================================================================================


# ====================================== Срезы массивов: доступ к подмассивам =========================================
# todo: Для доступа к срезу массива используется синтаксис: х[начало:конец:шаг]
# Одномерные массивы:
x = np.arange(10)
print('Одномерный массив: ', x)

print('Первые пять элементов - x[:5] ->', x[:5])
print('Элементы после индекса 5 - x[5:] ->', x[5:])
print('Элементы после индекса 5 - x[4:7] ->', x[4:7])

# =====================================================================================================================
